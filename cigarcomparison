import re


def parse_cigar(cigar_string):
    return [(int(length), op) for length, op in re.findall(r'(\d+)([MIDNSHP=X])', cigar_string)]


def read_and_process_reads(file_path):
    long_read_cigar_dict = {}
    subread_cigar_dict = {}

    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split('\t')
            if len(parts) == 3:  # Long read
                seq_id, cigar = parts[0], parts[2]
                long_read_cigar_dict[seq_id] = cigar
            elif len(parts) == 5:  # Subread
                seq_id, cigar, start, end = parts[0], parts[2], int(parts[3]), int(parts[4])
                if seq_id not in subread_cigar_dict:
                    subread_cigar_dict[seq_id] = []
                subread_cigar_dict[seq_id].append((cigar, (start, end)))

    return long_read_cigar_dict, subread_cigar_dict


def get_cigar_name(op):
    return {
        'M': 'match',
        'I': 'insertion',
        'D': 'deletion',
        'N': 'splice',
        'S': 'soft_clip',
        'H': 'hard_clip',
        'P': 'padding',
        '=': 'match',
        'X': 'mismatch'
    }.get(op, 'unknown')


def calculate_accuracy_precision_recall(summary, total_subread_bases):
    accurate_bases = summary['match'] + summary['insertion'] + summary['deletion'] + summary['splice']
    total_detected_bases = sum(summary[op] for op in ['match', 'insertion', 'deletion', 'splice', 'unmatched_sub'])

    # Accuracy
    accuracy = accurate_bases / total_subread_bases if total_subread_bases > 0 else 0

    # Precision
    true_positives = summary['match'] + summary['insertion'] + summary['deletion'] + summary['splice']
    false_positives = summary['unmatched_sub']
    precision = true_positives / (true_positives + false_positives) if (true_positives + false_positives) > 0 else 0

    # Recall
    false_negatives = summary['unmatched_long']
    recall = true_positives / (true_positives + false_negatives) if (true_positives + false_negatives) > 0 else 0

    return accuracy, precision, recall


def align_subread_to_longread(long_read_cigar, subread_cigar, start, end):
    long_cigar = parse_cigar(long_read_cigar)
    sub_cigar = parse_cigar(subread_cigar)

    # Restrict long_cigar to the region between start and end positions
    long_cigar_trimmed = []
    position = 0
    for length, op in long_cigar:
        if position + length <= start:
            position += length
            continue
        if position < end:
            if position < start:
                length -= (start - position)
                position = start
            if position + length > end:
                length = end - position
            long_cigar_trimmed.append((length, op))
            position += length
        if position >= end:
            break

    summary = {
        'match': 0,
        'mismatch': 0,
        'insertion': 0,
        'deletion': 0,
        'splice': 0,
        'soft_clip': 0,
        'hard_clip': 0,
        'padding': 0,
        'unmatched_long': 0,
        'unmatched_sub': 0
    }

    long_index = 0
    sub_index = 0

    while long_index < len(long_cigar_trimmed) and sub_index < len(sub_cigar):
        long_len, long_op = long_cigar_trimmed[long_index]
        sub_len, sub_op = sub_cigar[sub_index]

        if long_op == sub_op:
            common_len = min(long_len, sub_len)
            summary[get_cigar_name(long_op)] += common_len
            long_len -= common_len
            sub_len -= common_len

            if long_len == 0:
                long_index += 1
            else:
                long_cigar_trimmed[long_index] = (long_len, long_op)

            if sub_len == 0:
                sub_index += 1
            else:
                sub_cigar[sub_index] = (sub_len, sub_op)
        else:
            if long_op in ['I', 'D', 'N', 'S', 'H', 'P']:
                summary[get_cigar_name(long_op)] += long_len
                summary['unmatched_long'] += long_len
                long_index += 1
            elif sub_op in ['I', 'D', 'N', 'S', 'H', 'P']:
                summary[get_cigar_name(sub_op)] += sub_len
                summary['unmatched_sub'] += sub_len
                sub_index += 1
            else:
                common_len = min(long_len, sub_len)
                summary['unmatched_long'] += common_len
                summary['unmatched_sub'] += common_len
                long_len -= common_len
                sub_len -= common_len

                if long_len == 0:
                    long_index += 1
                else:
                    long_cigar_trimmed[long_index] = (long_len, long_op)

                if sub_len == 0:
                    sub_index += 1
                else:
                    sub_cigar[sub_index] = (sub_len, sub_op)

    while long_index < len(long_cigar_trimmed):
        length, op = long_cigar_trimmed[long_index]
        summary[get_cigar_name(op)] += length
        summary['unmatched_long'] += length
        long_index += 1

    while sub_index < len(sub_cigar):
        length, op = sub_cigar[sub_index]
        summary[get_cigar_name(op)] += length
        summary['unmatched_sub'] += length
        sub_index += 1

    total_subread_bases = sum(summary[op] for op in ['match', 'insertion', 'deletion', 'splice', 'unmatched_sub'])
    accuracy, precision, recall = calculate_accuracy_precision_recall(summary, total_subread_bases)

    return summary, accuracy, precision, recall


def compare_cigar_strings(long_read_cigar_dict, subread_cigar_dict, start_end_positions):
    results = []
    for seq_id, subread_cigars in subread_cigar_dict.items():
        if seq_id in long_read_cigar_dict:
            long_read_cigar = long_read_cigar_dict[seq_id]
            combined_summary = {
                'match': 0,
                'mismatch': 0,
                'insertion': 0,
                'deletion': 0,
                'splice': 0,
                'soft_clip': 0,
                'hard_clip': 0,
                'padding': 0,
                'unmatched_long': 0,
                'unmatched_sub': 0
            }
            for subread_cigar, (start, end) in subread_cigars:
                summary, accuracy, precision, recall = align_subread_to_longread(long_read_cigar, subread_cigar, start,
                                                                                 end)
                results.append((seq_id, subread_cigar, start, end, summary, accuracy, precision, recall))
                print(
                    f"Comparison Summary for Long Read CIGAR: {long_read_cigar} vs Subread CIGAR: {subread_cigar} (Sequence ID: {seq_id}):")
                for k, v in summary.items():
                    print(f"{k}: {v}")
                print(f"Accuracy: {accuracy:.4f}")
                print(f"Precision: {precision:.4f}")
                print(f"Recall: {recall:.4f}")
                print("\n")

                for key in combined_summary:
                    combined_summary[key] += summary[key]

            total_subread_bases = sum(
                combined_summary[op] for op in ['match', 'insertion', 'deletion', 'splice', 'unmatched_sub'])
            combined_accuracy, combined_precision, combined_recall = calculate_accuracy_precision_recall(
                combined_summary, total_subread_bases)

            print(f"Combined Summary for Long Read (Sequence ID: {seq_id}):")
            for k, v in combined_summary.items():
                print(f"{k}: {v}")
            print(f"Combined Accuracy: {combined_accuracy:.4f}")
            print(f"Combined Precision: {combined_precision:.4f}")
            print(f"Combined Recall: {combined_recall:.4f}")
            print("\n")
        else:
            print(f"Sequence ID {seq_id} not found in long reads.")

    return results


# Long read CIGAR strings
long_read_cigar_dict = {
    'read1': '69S508M5I570M4I389M2D12247N38M7978N108M2S',
    'read2': '100M10I200M5D300M'
}

# Subreads with different accuracy levels
subread_cigar_dict = {
    'read1': [
        ('69S508M5I570M4I389M2D12247N38M7978N108M2S', (0, 12818)),
        ('20M5I10M5D20M', (69, 508)),
        ('10M5I20M', (508, 1088)),
        ('15M10I15M', (1088, 1483))
    ],
    'read2': [
        ('50M10I50M', (0, 100)),
        ('20M5D30M', (100, 200)),
        ('150M', (200, 400))
    ]
}

start_end_positions = {
    'read1': [(0, 12818)],
    'read2': [(0, 600)]
}

results = compare_cigar_strings(long_read_cigar_dict, subread_cigar_dict, start_end_positions)
